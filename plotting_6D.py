# -*- coding: utf-8 -*-
"""
This file conducts the plotting needed for 6D Vlasov simulation, and has a whole
    bunch of modes of operation.

@author: Eric A. Comstock

v1.0, Eric A. Comstock, 3-Oct-2025
v0.4, Eric A. Comstock, 26-Sep-2025
v0.3, Eric A. Comstock, 2-Sep-2025
v0.2, Eric A. Comstock, 26-Aug-2025
v0.1, Eric A. Comstock, 5-Aug-2025
v0.0, Eric A. Comstock, 1-Aug-2024
"""

#### Import basic modules ####

import numpy as np              # Used for vector algebra and for getFEM
import matplotlib.pyplot as plt # Used for plotting if requested by the code
import matplotlib.colors as colors
import time

#colorlist = ["#000020","0000C0", "FF00FF", "FF"]
#cmap = colors.LinearSegmentedColormap.from_list("my_custom_cmap", colorlist, N=256)
cmap = plt.cm.plasma

def plot_conv(stuff, labels):
    # This function plots the results of a convergence for arbitrarily many functions,
    #   as well as the machine error as a seperate, dashed line.
    #
    # Inputs:
    #   stuff   is a list of datasets. Each dataset in this list i should contain
    #       two arrays or lists:
    #           i[0], which is the degrees of freedom from FEA (expressed on the x-axis) 
    #           i[1], which is relative RMS error (expressed on the y-axis)
    #   labels  is a list of strings used in the legend (one label per dataset)
    #
    # Outputs:
    #   Plots of the covergence, compared with machine precision
    
    # Generate figure, to add plots to later
    plt.figure(figsize  = (4, 1.8))
    
    # Initialize minimum and maximum values of the degrees of freedom, so that the
    #   minima and maxima for all datasets may be calculated.
    min_x               = 1e6
    max_x               = 1e6
    
    # Main for loop that plots each function and ensures that the minima and maxima
    #   of all datasets combined are calculated
    for i in stuff:
        # Plot the current dataset i
        ax              = plt.loglog(i[0], i[1])
        
        # Remove upper and rightmost lines to make graph simpler
        plt.gca().spines['top'].set_visible(False)
        plt.gca().spines['right'].set_visible(False)
        
        # If one of the datasets goes below the global minimum dof, adjust the dof
        #   minimum to match it
        if np.min(i[0]) < min_x:
            min_x       = np.min(i[0])
        
        # If one of the datasets goes below the global maximum dof, adjust the dof
        #   maximum to match it
        if np.max(i[0]) > max_x:
            max_x       = np.max(i[0])
    
    # Plot the loglog plot of the machine precision - here defined as the square
    #   root of the machine epsilon since we are using an RMS error mechanism.
    # This is plotted from the global minimum dof to the global maximum dof
    plt.loglog([min_x, max_x], np.sqrt(np.finfo(float).eps) * np.ones((2)), 'r--')
    
    # Add labels to the axes and add a legend to the plots
    plt.xlabel('FEA DoF', labelpad=2)
    plt.ylabel('Relative error (RMS)', labelpad=2)
    plt.legend(labels + ['Machine precision'])
    
    # Save figure as a .pdf file, in such a way that it does not overwrite any others
    plt.savefig('Convergence' + time.strftime("%Y,%m,%d %H,%M,%S", time.gmtime()) + '.pdf', format='pdf', bbox_inches='tight')

def plot2D(X, Y, data, ctext, lpd):
    # This function plots 1 2D filled contour graph
    #   as well as the machine error as a seperate, dashed line.
    #
    # Inputs:
    #   X       is the x-coordinates, generated by np.meshgrid as a 2D array
    #   Y       is the y-coordinates, generated by np.meshgrid as a 2D array
    #   data    is the data being plotted, as a 2D array
    #   ctext   are the labels of the contours
    #   lpd     is the pading of the labels
    #
    # Outputs:
    #   Plots of the covergence, compared with machine precision
    
    # If the data range is small, mess with the maximum density to make the data
    #   in the center of the range
    vmax                    = np.max(data) + np.abs(np.min(data))
    # Similarly, ensure that the data range goes down to zero
    norm                    = colors.Normalize(vmin=0, vmax=vmax)
    
    # This ensures that the colorbar is plotted correctly - a second, modified set
    #   of data is deployed underneath the real data, and the colorbar is adapted
    #   to that data, which has the highest and lowest colorbar values.
    data_modified           = data.copy() # Copy the real data without reference
    data_modified[0,0]      = 0 # ensure that the minimum values are accounted for
    data_modified[-1,-1]    = vmax # ensure that the maximum values are accounted for
    # Plot the modified data and set the colorbar to them
    cf                      = plt.contourf(X, Y, data_modified, levels = 4, cmap = cmap, norm = norm)
    cbar                    = plt.colorbar() # Plot the colorbar for the modified data
    
    # Set the colorbar labels
    cbar.set_label(ctext, labelpad = lpd)
    
    # Actual plotting the filled contour, on top of the modified data (to cover it up, but not the colorbar)
    plt.contourf(X, Y, data, levels = 4, cmap = cmap, norm = norm)
    
    # Ensure that the plots are tightly squeezed, to make sure they fit in the paper
    plt.locator_params(tight=True, nbins=6)

def plot6D(grid_x, grid_p, v_x, v_y, density_xy, density_xz, density_yz, density_uv, density_uw, density_vw):
    # This function plots six 2D representations of a 6D space, three corresponding
    #   to each triplet of dimensions.
    #
    # Inputs:
    #   grid_x          is the position grid of the FEM calculation mesh
    #   grid_p          is the momentum grid of the FEM calculation mesh
    #   v_x             is the velocity of the plasma horizontally in km/s
    #   v_y             is the velocity of the plasma vertically in km/s
    #   density__       are the density values for the six plots, in meshgrid form.
    #
    # Outputs:
    #   Plots of the xy, xz, yz, uv, uw, and vw distributions of densities, done
    #       however this function was called
    
    # Create meshgrids for the plotting
    X1, X2      = np.meshgrid(grid_x, grid_x)
    P1, P2      = np.meshgrid(grid_p, grid_p)
    
    plt.figure(figsize  = (3.7, 5.5))# Generate the figure
    plt.subplots_adjust(left = 0.0, right = 1, top = 0.9, bottom = 0.15,
                    wspace = 0.72, hspace = 0.5)# ensure subplots are the right size
    
    # Label pads are negative to ensure that the graph is sufficiently compressed
    #   to fit in the paper
    labelpadx   = -1
    labelpady   = -3

    # Plot x vs y in position-space
    plt.subplot(321)
    plot2D(X1, X2, np.transpose(density_xy) / 1e12, 'f ($10^{12} m^{-3}$)', 0)
    plt.xlabel('$x_1$ (m)', labelpad            = labelpadx)
    plt.ylabel('$x_2$ (m)', labelpad            = labelpady)
    
    # Plot x vs z in position-space
    plt.subplot(323)
    plot2D(X1, X2, np.transpose(density_xz) / 1e12, 'f ($10^{12} m^{-3}$)', 0)
    plt.xlabel('$x_1$ (m)', labelpad            = labelpadx)
    plt.ylabel('$x_3$ (m)', labelpad            = labelpady)
    
    # Plot y vs z in position-space
    plt.subplot(325)
    plot2D(X1, X2, np.transpose(density_yz) / 1e12, 'f ($10^{12} m^{-3}$)', 0)
    plt.xlabel('$x_2$ (m)', labelpad            = labelpadx)
    plt.ylabel('$x_3$ (m)', labelpad            = labelpady)
    
    # Plot u vs v in momentum-space
    plt.subplot(322)
    plot2D(P1 + v_x, P2 + v_y, np.transpose(density_uv) / 1e12, 'f ($10^{12} m^{-3}s^3$)', 0)
    plt.xlabel('$p_1/m_i$ (km/s)', labelpad     = labelpadx)
    plt.ylabel('  $p_2/m_i$ (km/s)', labelpad   = labelpady)
    
    # Plot u vs w in momentum-space
    plt.subplot(324)
    plot2D(P1 + v_x, P2, np.transpose(density_uw) / 1e12, 'f ($10^{12} m^{-3}s^3$)', 0)
    plt.xlabel('$p_1/m_i$ (km/s)', labelpad     = labelpadx)
    plt.ylabel('  $p_3/m_i$ (km/s)', labelpad   = labelpady)
    
    # Plot v vs w in momentum-space
    plt.subplot(326)
    plot2D(P1 + v_y, P2, np.transpose(density_vw) / 1e12, 'f ($10^{12} m^{-3}s^3$)', 0)
    plt.xlabel('$p_2/m_i$ (km/s)', labelpad     = labelpadx)
    plt.ylabel('  $p_3/m_i$ (km/s)', labelpad   = labelpady)
    
    # Save figure as a .pdf file, in such a way that it does not overwrite any others
    plt.savefig('Density_graphs' + time.strftime("%Y,%m,%d %H,%M,%S", time.gmtime()) + '.pdf', format='pdf', bbox_inches='tight')

def plot_avg_density_maps(grid_x, grid_p, density, x_inv, y_inv, z_inv, u_inv, v_inv, w_inv, v_x, v_y):
    # This function plots the results of a 6D FEM method applied to the Vlasov equation.
    #   It generates plots made of the total densitiy within each segment os a 2D
    #   plane, crushing the distribution together instead of slicing it.
    #
    # Inputs:
    #   grid_x          is the position grid of the FEM calculation mesh
    #   grid_p          is the momentum grid of the FEM calculation mesh
    #   density         is the density (particles / (m_NO^3 * m^6 / ms^3)) of the
    #                       plasma generated by the FEM, as a list versus on FEM
    #                       node ID
    #   __inv           are the inverted keys for which FEM node goes to which
    #                       x, y, z, u, v, w position
    #   v_x             is the velocity of the plasma horizontally in km/s
    #   v_y             is the velocity of the plasma vertically in km/s
    #
    # Outputs:
    #   Plots of the xy, xz, yz, uv, uw, and vw distributions of densities, each
    #       integrated over the entire space.
    
    # Extract point numbers and plotting information from the grids and particle density data
    num_points = len(density) # Total number of FEM points to evaluate
    Nx         = len(grid_x) # Number of points in the position grid
    Np         = len(grid_p) # Number of points in the momentum grid
    
    # Initializing graphed outputs as zero numpy arrays for preallocation and easier storage
    density_xy = np.zeros([Nx, Nx])
    density_xz = np.zeros([Nx, Nx])
    density_yz = np.zeros([Nx, Nx])
    density_uv = np.zeros([Np, Np])
    density_uw = np.zeros([Np, Np])
    density_vw = np.zeros([Np, Np])
    
    # Iterate through every FEM point, numerically integrating their densities together
    #   for graphing purposes - here, the points at a 4D slide of 6D space are summed
    #   and then plotted in 2D space.
    for i in range(num_points):
        # Generate graphs in position space, weighting them by the cell hypervolume in the 4 dimensions being crushed together
        xi     = x_inv[i]
        yi     = y_inv[i]
        zi     = z_inv[i]
        density_xy[xi][yi] += (grid_p[1]-grid_p[0]) ** 3 * (grid_x[1]-grid_x[0]) * density[i]
        density_xz[xi][zi] += (grid_p[1]-grid_p[0]) ** 3 * (grid_x[1]-grid_x[0]) * density[i]
        density_yz[yi][zi] += (grid_p[1]-grid_p[0]) ** 3 * (grid_x[1]-grid_x[0]) * density[i]
        
        # Generate graphs in momentum space, weighting them by the cell hypervolume in the 4 dimensions being crushed together
        ui     = u_inv[i]
        vi     = v_inv[i]
        wi     = w_inv[i]
        density_uv[ui][vi] += (grid_x[1]-grid_x[0]) ** 3 * (grid_p[1]-grid_p[0]) * density[i]
        density_uw[ui][wi] += (grid_x[1]-grid_x[0]) ** 3 * (grid_p[1]-grid_p[0]) * density[i]
        density_vw[vi][wi] += (grid_x[1]-grid_x[0]) ** 3 * (grid_p[1]-grid_p[0]) * density[i]
    
    # Call function to actually plot everything
    plot6D(grid_x, grid_p, v_x, v_y, density_xy, density_xz, density_yz, density_uv, density_uw, density_vw)

def plot_slice_density_maps(grid_x, grid_p, density, x_inv, y_inv, z_inv, u_inv, v_inv, w_inv, v_x, v_y):
    # This function plots the results of a 6D FEM method applied to the Vlasov equation.
    #   It generates plots made of the total densitiy within each segment os a 2D
    #   plane, slicing the distribution in position space and crushing it in momentum space
    #   and similarly in momentum space
    #
    # Inputs:
    #   grid_x          is the position grid of the FEM calculation mesh
    #   grid_p          is the momentum grid of the FEM calculation mesh
    #   density         is the density (particles / (m_NO^3 * m^6 / ms^3)) of the
    #                       plasma generated by the FEM, as a list versus on FEM
    #                       node ID
    #   __inv           are the inverted keys for which FEM node goes to which
    #                       x, y, z, u, v, w position
    #   v_x             is the velocity of the plasma horizontally in km/s
    #   v_y             is the velocity of the plasma vertically in km/s
    #
    # Outputs:
    #   Plots of the xy, xz, yz, uv, uw, and vw distributions of densities, sliced
    #       in position and velocity
    
    # Extract point numbers and plotting information from the grids and particle density data
    num_points = len(density) # Total number of FEM points to evaluate
    Nx         = len(grid_x) # Number of points in the position grid
    Np         = len(grid_p) # Number of points in the momentum grid
    
    xms        = (Nx - 1) // 2 # x-momentum slice - midway in the position coordinates
    pms        = (Np - 1) // 2 # p-momentum slice - midway in the momentum coordinates
    
    # Initializing graphed outputs as zero numpy arrays for preallocation and easier storage
    density_xy = np.zeros([Nx, Nx])
    density_xz = np.zeros([Nx, Nx])
    density_yz = np.zeros([Nx, Nx])
    density_uv = np.zeros([Np, Np])
    density_uw = np.zeros([Np, Np])
    density_vw = np.zeros([Np, Np])
    
    # Iterate through every FEM point, slicing and integrating their densities together
    #   for graphing purposes.
    for i in range(num_points):
        # Generate graphs in position space, weighting them by the cell hypervolume in the 3 dimensions being crushed together
        #   but not the one sliced through
        xi     = x_inv[i]
        yi     = y_inv[i]
        zi     = z_inv[i]
        if zi == xms: density_xy[xi][yi] += (grid_p[1]-grid_p[0]) ** 3 * density[i]
        if yi == xms: density_xz[xi][zi] += (grid_p[1]-grid_p[0]) ** 3 * density[i]
        if xi == xms: density_yz[yi][zi] += (grid_p[1]-grid_p[0]) ** 3 * density[i]
        
        # Generate graphs in momentum space, weighting them by the cell hypervolume in the 3 dimensions being crushed together
        #   but not the one sliced through
        ui     = u_inv[i]
        vi     = v_inv[i]
        wi     = w_inv[i]
        if wi == pms: density_uv[ui][vi] += (grid_x[1]-grid_x[0]) ** 3 * density[i]
        if vi == pms: density_uw[ui][wi] += (grid_x[1]-grid_x[0]) ** 3 * density[i]
        if ui == pms: density_vw[vi][wi] += (grid_x[1]-grid_x[0]) ** 3 * density[i]
    
    # Call function to actually plot everything
    plot6D(grid_x, grid_p, v_x, v_y, density_xy, density_xz, density_yz, density_uv, density_uw, density_vw)